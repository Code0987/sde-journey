# DSA

## General Tips

- Use a Heap for K Elements
  - Rule: When dealing with top/maximum/minimum/closest K elements among N elements, use a Heap.
  - Example Scenario: Finding the top -largest numbers in an array.

- Binary Search or Two Pointers for Sorted Inputs
  - Rule: If the input is a sorted array or list, use Binary Search or the Two Pointers strategy.
  - Example Scenario: Finding a pair of numbers that sum up to a target in a sorted array.

- Backtracking or BFS for Combinations
  - Rule: For trying all combinations or permutations of the input, use Backtracking or Breadth-First Search (BFS).
  - Example Scenario: Generating all subsets of a given set.

- BFS or DFS for Trees and Graphs
  - Rule: Most Tree or Graph questions can be solved using BFS or DFS.
  - Example Scenario: Finding the shortest path in a graph.

- Convert Recursion to Iteration with a Stack
  - Rule: Every recursive solution can be rewritten as an iterative one using a Stack.
  - Example Scenario: Converting recursive tree traversal to iterative using a stack.

- Optimize Array Problems with HashMap or Sorting
  - Rule: If the array solution takes O(nÂ²) time, try using HashMap/Set for O(n) time or sorting for O(n log n) time.
  - Example Scenario: Finding duplicates in an array.

- Use Dynamic Programming for Optimization Problems
  - Rule: If the problem involves maximization or minimization, use Dynamic Programming.
  - Example Scenario: Solving the knapsack problem.

- HashMap or Trie for Common Substrings
  - Rule: For finding common substrings among multiple strings, use a HashMap or a Trie.
  - Example Scenario: Finding the longest common prefix among strings.

- Trie for String Search and Manipulation
  - Rule: When searching or manipulating a collection of strings, a Trie is the best fit.
  - Example Scenario: Implementing autocomplete functionality.

- Fast & Slow Pointers for Linked Lists
  - Rule: For Linked List problems, especially when extra space isn't allowed, use the Fast & Slow Pointer approach.
  - Example Scenario: Detecting a cycle in a linked list.

## Readings

- <https://leetcode.com/discuss/interview-question?currentPage=-orderBy=hot&query=>
- <https://leetcode.com/discuss/compensation?currentPage=2&orderBy=newest_to_oldest&query=>
- <https://neetcode.io/roadmap>
- <https://www.techinterviewhandbook.org/grind75>
- <https://github.com/dipjul/Grokking-the-Coding-Interview-Patterns-for-Coding-Questions>
- <https://leetcodewizard.io/problem-database>

- Dynamic Programming
  - <https://lnkd.in/gHYgRDSZ>
- Greedy Algorithms
  - <https://lnkd.in/gianQPuw>
- Graphs
  - <https://lnkd.in/gcHRz5-p>
- Backtracking
  - <https://lnkd.in/gersVnrz>
- Linked List
  - <https://lnkd.in/gT_FhqYa>
- Bit Manipulation
  - <https://lnkd.in/gtZZc6tR>
- Hash Table and Map
  - <https://lnkd.in/gPsUh6w5>
- Disjoint Set Union (Union Find)
  - <https://lnkd.in/gQx74mJc>
- Bridges and Articulation Points
  - <https://lnkd.in/gRpJ6qxN>
- Dijkstra Algorithm
  - <https://lnkd.in/gRsxH7Th>
- Bellman Ford Algorithm
  - <https://lnkd.in/gBN54_mc>
- Floyd Warshall Algorithm
  - <https://lnkd.in/g6zvRYbb>
- Topological Sort
  - <https://lnkd.in/gBaaZCbM>
- Sliding Window
  - <https://lnkd.in/gbMnsS8i>
- Trie
  - <https://lnkd.in/gDqU7Ypy>
- Monotonic Queue and Priority Queue
  - <https://lnkd.in/gzrcfZtj>
- Heaps
  - <https://lnkd.in/gNsjGw8p>
- Trees
  - <https://lnkd.in/g5vXWFu3>
- Binary Search
  - <https://lnkd.in/gjykw7x2>
- Two Pointers
  - <https://lnkd.in/gZeG-PXb>

## Practice

- <https://neetcode.io/roadmap>
