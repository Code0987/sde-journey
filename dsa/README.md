# DSA

## General Tips

- Use a Heap for K Elements
  - Rule: When dealing with top/maximum/minimum/closest K elements among N elements, use a Heap.
  - Example Scenario: Finding the top -largest numbers in an array.

- Binary Search or Two Pointers for Sorted Inputs
  - Rule: If the input is a sorted array or list, use Binary Search or the Two Pointers strategy.
  - Example Scenario: Finding a pair of numbers that sum up to a target in a sorted array.

- Backtracking or BFS for Combinations
  - Rule: For trying all combinations or permutations of the input, use Backtracking or Breadth-First Search (BFS).
  - Example Scenario: Generating all subsets of a given set.

- BFS or DFS for Trees and Graphs
  - Rule: Most Tree or Graph questions can be solved using BFS or DFS.
  - Example Scenario: Finding the shortest path in a graph.

- Convert Recursion to Iteration with a Stack
  - Rule: Every recursive solution can be rewritten as an iterative one using a Stack.
  - Example Scenario: Converting recursive tree traversal to iterative using a stack.

- Optimize Array Problems with HashMap or Sorting
  - Rule: If the array solution takes O(n²) time, try using HashMap/Set for O(n) time or sorting for O(n log n) time.
  - Example Scenario: Finding duplicates in an array.

- Use Dynamic Programming for Optimization Problems
  - Rule: If the problem involves maximization or minimization, use Dynamic Programming.
  - Example Scenario: Solving the knapsack problem.

- HashMap or Trie for Common Substrings
  - Rule: For finding common substrings among multiple strings, use a HashMap or a Trie.
  - Example Scenario: Finding the longest common prefix among strings.

- Trie for String Search and Manipulation
  - Rule: When searching or manipulating a collection of strings, a Trie is the best fit.
  - Example Scenario: Implementing autocomplete functionality.

- Fast & Slow Pointers for Linked Lists
  - Rule: For Linked List problems, especially when extra space isn't allowed, use the Fast & Slow Pointer approach.
  - Example Scenario: Detecting a cycle in a linked list.

## Data Structures

- Arrays, Strings and Linked Lists
  - <https://lnkd.in/gT_FhqYa>
- Stacks, Queues, Heaps and Priority Queues
  - <https://lnkd.in/gzrcfZtj>
  - <https://lnkd.in/gNsjGw8p>
- Hash Maps and Hash Sets
  - <https://lnkd.in/gPsUh6w5>
- Trees (Binary Trees, Binary Search Trees, AVL Trees)
  - <https://lnkd.in/g5vXWFu3>
- Graphs (DFS, BFS, Dijkstra’s, Bellman Ford, Floyd-Warshall)
  - <https://lnkd.in/gcHRz5-p>
  - <https://lnkd.in/gRsxH7Th>
  - <https://lnkd.in/gBN54_mc>
  - <https://lnkd.in/gBaaZCbM>
  - <https://lnkd.in/g6zvRYbb>
  - <https://lnkd.in/gRpJ6qxN>
- Tries
  - <https://lnkd.in/gDqU7Ypy>
- Disjoint Sets (Union-Find)
  - <https://lnkd.in/gQx74mJc>

## Algorithms

- Sorting (Quick Sort, Merge Sort, Heap Sort)
- Searching (Binary Search, Ternary Search)
  - <https://lnkd.in/gjykw7x2>
- Recursion and Backtracking
  - <https://lnkd.in/gersVnrz>
- Dynamic Programming (Knapsack, Longest Common Subsequence, LIS)
  - <https://lnkd.in/gHYgRDSZ>
- Greedy Algorithms
  - <https://lnkd.in/gianQPuw>
- Divide and Conquer
- Sliding Window and Two Pointer Techniques
  - <https://lnkd.in/gbMnsS8i>
  - <https://lnkd.in/gZeG-PXb>
- Bit Manipulation
  - <https://lnkd.in/gtZZc6tR>
- Graph Algorithms (Kruskal, Prim, Topological Sort)
- String Matching (KMP, Rabin-Karp)

## Practice

- <https://leetcode.com/discuss/interview-question?currentPage=-orderBy=hot&query=>
- <https://leetcode.com/discuss/compensation?currentPage=2&orderBy=newest_to_oldest&query=>
- <https://neetcode.io/roadmap>
- <https://www.techinterviewhandbook.org/grind75>
- <https://github.com/dipjul/Grokking-the-Coding-Interview-Patterns-for-Coding-Questions>
- <https://leetcodewizard.io/problem-database>
